# Работа с Git
## 1. Проверка наличия установленного Git
В терминале выполнить команду: 
```
git version
``` 
Если Git установлен, появится сообщение с  
информацией о версии программы. Иначе будет
сообщение об ошибке.

## 2. Установка Git

Загружаем последнюю версию [Git](https://git-scm.com/downloads "загрузить") с сайта
https://git-scm.com/downloads  
Устанавливаем с настройками по умолчанию.

## 3. Настройка Git
При первом спользовании Git необходимо представится. Для этого нужно в терминале ввести две команды:
```
git config --global user.name "имя пользователя"
git config --global user.email "user@pochta.ru"
```
## 4. Инициализация репозитория
Получить репозиторий можно двумя способами.
1. В терминале перейти к папке, в которой хотим создать репозиторий. Выполняем команду:
```
git init
```
![слайд git_init](git_%20init.png)

2. Клонировать существующий репозиторий Git из любого места. Сделать это можно так:
```
git clone <адрес_репозитория>
```

## 5. Запись изменений в репозиторий
Каждый файл в рабочей папке (репозитории) может находится в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (не отслеживаемые)
Отслеживаемые файлы могут быть неизмененными, измененными или подготовленными к коммиту  

**Команда**
```
git status
```
Показывает текущее состояние гита, есть 
ли изменения, которые нужно закоммитить
(сохранить)  

**Команда `git add`**

Добавим все файлы проекта к нам в будующее сохранение (commit)
```
git add .
```
*Или так*
```
git add --all
```
*Если хотим добавить конкретный файл то можно так*
```
git add <имя_файла>
```

![слайд git_add](git_add.png)

*Писать название файла целиком не обязательно: терминал дозаполнит данные автоматически, достаточно написать несколько первых знаков имени нужного файла и на клавиатуре нажать клавишу TAB*

***Игнорирование файлов***

Бывает так, что некоторый класс файлов вы не хотите ни автоматически добавлять в репозиторий, ни видеть в списке неотслеживаемых. В эту категорию, как правило, попадают автоматически генерируемые файлы, например журналы регистрации или файлы, генерируемые системой сборки. В подобных случаях создается файл `.gitignore` со списком соответствующих паттернов.

**Команда git commit**

Создаем сохранение (commit). Обязательно указываем комментарий
и не забываем про кавычки
```
git commit -m "<комментарий>"
```
![слайд git_commit](git_commit.png)

Команда `git commit` берёт все данные, добавленные в индекс с помощью `git add`, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

**Команда**
```
git commit -a -m "<комментарий>"
```
*Или*
```
git commit -am "<комментарий>"
```
сразу добавляет все отслеживаемые файлы и создает коммит.

_**Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:**_

* Создан новый функционал
* Добавлен новый блок на верстке
* Исправлены ошибки по коду
* Вы завершили рабочий день и хотите сохранить код

Это поможет держать вашу ветки в чистоте и порядке. Тем самым, вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

## 6. Просмотр истории коммитов

**Команда**
```
git log
```
выводит журнал изменений

![слайд git_log](git_log.png)

Вывод сокращенного журнала изменений выполняется с помощью команды
```
git log --oneline
``` 
### Переключение между версиями
**Команда**
```
git checkout <хеш_коммита>
```
*Писать хеш целиком не обязательно: достаточно написать первые четыре-шесть символов хеша*

***Переключение между сохранениями (коммитами).***  
Перед переключением версии файла в Git используйте команду `git log`, чтобы увидеть количество сохранений.  
Для работы нужно указать не только интересующий вас коммит, но и вернуться в ту ветку где работаем, при помощи команды
```
git checkout <название_ветки>
```
**Команда** 
```
git diff
```
![слайд git_diff](git_diff.png)

Показывает разницу между текущим файлом и сохранённым.
## 7. Ветки

***Ветка*** - это набор commit (кружок на картинке), которые идут друг за другом. У ветки есть название, основную ветку чаще всего называют master (на картинках будет называться main) . Если говорить простыми словами, то ветка master - это наш проект.

Другие ветки - это отдельное место для реализации нового функционала или исправление багов (ошибок) нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master.
![слайд ветка](https://habrastorage.org/r/w1560/getpro/habr/upload_files/753/f85/4b2/753f854b2ca82a2a5112e9717d1a5856.png)

### Создание веток

**Команда для того, чтобы создать новую ветку:**
```
git branch <название_ветки>
```
_или вот так_
```
git checkout -b <название_ветки>
```
![слайд 2 ветка](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2c3/0a1/699/2c30a16996c18d3c2496bb6bde28cc90.png)

Эти команды делают тоже самое, только второй вариант позволяет сразу переключиться в новую ветку. Вносить изменения в новую ветку можно сразу после ее создания.

**Команда чтобы переключаться между ветками:**
```
git checkout <название_ветки>
```
### Слияние веток

После того, как вы завершили работу над своей задачей, ветку можно слить в master . Для этого сначала нужно переключиться в ветку master выполнив следующую команду:

**Команда**
```
git checkout <на рисунке main*>
```
Далее делаем слияние нужной ветки, в ветку в которой мы находимся на рисунке это main*

**Команда**
```
git merge <название_ветки>
```
![слайд 3 ветка](https://habrastorage.org/r/w1560/getpro/habr/upload_files/574/bb2/a87/574bb2a8719a01dad2f63e803f550a66.png)

_На рисунке ветка bugFix сливается с основной веткой_

### Удаление веток
Удаление веток не такой простой процесс, как может показаться. Можно случайно удалить несохраненные изменения в исходном коде, что приведет к нежелательным последствиям. Поэтому здесь нужно действовать осторожно. С операцией удаления над ветками справляется уже привычная команда `git branch` с параметром **-d**:

Удалить ненужную ветку можно **командой**:
```
git branch -d <название_ветки>
```
Для корректного удаления нужно помнить несколько правил, чтобы не получить ошибки:

Нельзя удалить ветку, в которой вы находитесь. Git выкинет ошибку и не произведет удаление. Следовательно, нужно перейти на другую ветку.
Git не позволит удалить ветку, у которой есть несохраненные изменения. Так мы избегаем ситуации, когда часть написанного кода будет безвозвратно утеряна. Если же мы уверены, что изменения в этой версии не нужны и их можно смело удалять, то вместо флага **-d** используем **-D**:
```
git branch -D <название ветки>
```
Соблюдая все условия, нам удастся удалить указанную ветвь.

### Конфликты при слиянии

Процесс слияния далеко не всегда проходит гладко. Если в двух ветках, которые вы собираетесь слить, вы внесли разные изменения в один и тот же файл, Git не сможет просто взять и объединить их.
В этом случае Git не может автоматически создать коммит слияния. Система приостанавливает процесс до момента разрешения конфликта. Посмотреть, какие файлы не прошли слияние после возникновения конфликта, позволяет команда `git status`

_Основные способы разрешения конфликтов:_

Автоматический способ
* оставить текущую версию
* использовать новую версию

Ручной способ
* оставить обе версии и уже вручную править

_После разрешения конфликта необходимо сделать коммит слияния_.

В сообщении коммита следует указать, какие ветки вы сливали, и вкратце перечислить внесенные изменения.

###  Работа с удалёнными репозиториями

Удаленный (иногда говорят "внешний") репозиторий – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.
Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель **HEAD**, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка **main**, а у нас будет копия этой ветки – **origin/main**.

Для этого нужно:
1. Создать аккаунт на GitHub
2. Создать локальный репозиторий
3. Создать удаленный репозиторий
4. Связать удаленный репозиторий с локальным

Добавить удаленный репозиторий к проекту:
```
git remote add <имя для репозитория> <адрес репозитория>
```
Иногда возникает необходимость забыть удаленный репозиторий. Для этого существует команда `git remote remove`
```
git remote remove <название удаленного репозитория>
```
Клонирование репозитория.

Необходимость клонировать существующий удаленный репозиторий возникает в ситуациях, когда вы решаете поработать над уже существующим кодом. Для выполнения этой операции в Git предусмотрена команда `git clone`
```
git clone <ссылка на удаленный репозиторий>
```
Для получения и слияния изменений из удаленного репозитория используется команда:
```
git pull
```
Отправить изменения локального репозитория на удаленный команда:
```
git push
```
### PULL REQUEST
Пулл-реквест (от англ. pull-request – запрос pull) – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.

